// -*- coding: utf-8; mode: groovy -*-

import jp.classmethod.aws.gradle.ec2.AmazonEC2PluginExtension;
import jp.classmethod.aws.gradle.ec2.AmazonEC2ImportKeyTask;
import jp.classmethod.aws.gradle.ec2.AmazonEC2RunInstanceTask;
import jp.classmethod.aws.gradle.ec2.AmazonEC2StartInstanceTask;
import jp.classmethod.aws.gradle.ec2.AmazonEC2StopInstanceTask;
import jp.classmethod.aws.gradle.ec2.AmazonEC2TerminateInstanceTask;
import jp.classmethod.aws.gradle.ec2.AmazonEC2WaitInstanceStatusTask;

import jp.classmethod.aws.gradle.rds.AmazonRDSPluginExtension;
import jp.classmethod.aws.gradle.rds.AmazonRDSCreateDBInstanceTask;
import jp.classmethod.aws.gradle.rds.AmazonRDSDeleteDBInstanceTask;
import jp.classmethod.aws.gradle.rds.AmazonRDSWaitInstanceStatusTask;


import com.amazonaws.AmazonServiceException

import com.amazonaws.services.ec2.AmazonEC2
import com.amazonaws.services.ec2.model.CreateTagsRequest
import com.amazonaws.services.ec2.model.DescribeInstancesRequest
import com.amazonaws.services.ec2.model.DescribeInstancesResult
import com.amazonaws.services.ec2.model.Instance
import com.amazonaws.services.ec2.model.Tag

import com.amazonaws.services.rds.AmazonRDS;
import com.amazonaws.services.rds.model.DBInstance;
import com.amazonaws.services.rds.model.DescribeDBInstancesRequest;
import com.amazonaws.services.rds.model.DescribeDBInstancesResult;


buildscript {
	repositories {
		mavenCentral()
		maven { url "https://plugins.gradle.org/m2/" }
	}
	dependencies {
		classpath "jp.classmethod.aws:gradle-aws-plugin:0.+"
		classpath "org.hidetake:gradle-ssh-plugin:2.7.0"
		classpath "io.spring.gradle:dependency-management-plugin:0.5.4.RELEASE"

		classpath fileTree("../libs/buildlibs").include('jtds-*.jar', 'mysql-conn*.jar', 'ojdbc*.jar', 'postgres*.jar', 'sqljdbc*.jar')
	}
}


apply plugin: "java"
apply plugin: "jp.classmethod.aws.ec2"
apply plugin: "jp.classmethod.aws.rds"
apply plugin: "org.hidetake.ssh"


dependencies {
    compile 'com.amazonaws:aws-java-sdk-s3'
}


if (hasProperty('instanceTargetDb') == false) { ext.instanceTargetDb = "MySQL" }
if (hasProperty('propertiesFile') == false) { ext.propertiesFile = "build-aws-tests.properties" }
if (hasProperty('scriptFile') == false) { ext.scriptFile = "build-aws-tests.sh" }


Properties properties = new Properties()
properties.load(new FileInputStream(project.propertiesFile))


aws {
	profileName = properties.getProperty("awsCredentialsProfile")
	region = properties.getProperty("awsRegion")
}

ssh.settings {
	knownHosts = allowAnyHosts
}


//---------------------------------------------- AWS/SSH Instances ----------------------------------------------//

if (hasProperty('instanceId') == false) { ext.instanceId = "" }
if (hasProperty('instancePublicDnsName') == false) { ext.instancePublicDnsName = "" }


task importKey(type: AmazonEC2ImportKeyTask) {
	keyName properties.getProperty("keysKeyName")
	publicKeyMaterial properties.getProperty("keysPublicKeyMaterial")
	ifNotExists true
}


task launchInstance(type: AmazonEC2RunInstanceTask, dependsOn: importKey) {
	ami properties.getProperty("awsInstanceAmi")
	keyName properties.getProperty("keysKeyName")
	instanceType properties.getProperty("awsInstanceType")

	userData "#! /bin/bash\nyum -y update"

	securityGroupIds = new java.util.ArrayList<String>()
	securityGroupIds += properties.getProperty("awsSecurityGroupId")

	doLast {
		project.instanceId = runInstancesResult.getReservation().getInstances().get(0).instanceId

		println("Launched Instance = "+ runInstancesResult.getReservation().getInstances().get(0))
	}
}


task stopInstance(type: AmazonEC2StopInstanceTask) {
	doFirst {
		instanceIds += project.instanceId
	}
}

task startInstance(type: AmazonEC2StartInstanceTask) {
	doFirst {
		instanceIds += project.instanceId
	}
}

task terminateInstance(type: AmazonEC2TerminateInstanceTask) {
	doFirst {
		instanceIds += project.instanceId
	}

	doLast {
		println("Terminated Instance = "+ instanceIds)
	}
}


task waitInstanceStatusLaunched(type: AmazonEC2WaitInstanceStatusTask) {
	loopWait = 2

	doFirst {
		instanceId = project.instanceId
	}

	doLast {
		println("Launched Instance = "+ instanceId)
	}
}

task waitInstanceStatusTerminated(type: AmazonEC2WaitInstanceStatusTask) {
	loopWait = 2

	doFirst {
		instanceId = project.instanceId
	}

	doLast {
		println("Terminated Instance = "+ instanceId)
	}
}


task setupInstance {
	doLast {
		setInstanceTagName( project.instanceId,
			properties.getProperty("awsInstanceName") +" ("+ project.instanceTargetDb +")"
		)

		sleep(60 * 1000)
	}
}

task describeInstance {
	doLast {
		String publicDnsName = getInstancePublicDnsName(project.instanceId)

		project.instancePublicDnsName = publicDnsName;

		println("Described Instance = "+ publicDnsName )
	}
}


task executeRemoteInstance(dependsOn: describeInstance) {
	doLast {
		ssh.run {
			session(
				host: project.instancePublicDnsName, user: properties.getProperty("sshUsername"),
				identity: file( properties.getProperty("keysPrivateKeyFile") )
			) {
				executeScript( file( project.scriptFile ), logging: "none", interaction: {
					when(line: _, from: standardOutput) { line -> println( line ) }
					when(line: _, from: standardError) { line -> println( line ) }
				})
			}
		}
	}
}


String getInstancePublicDnsName(String instanceId) {
	DescribeInstancesResult describeInstancesResult = getAmazonEC2Client().describeInstances(
		new DescribeInstancesRequest().withInstanceIds( instanceId )
	)

	String instancePublicDnsName = describeInstancesResult.reservations.instances.get(0).publicDnsName;

	return instancePublicDnsName.substring(1, instancePublicDnsName.length() - 1);
}

void setInstanceTagName(String instanceId, String instanceName) {
	CreateTagsRequest request = new CreateTagsRequest()

    getAmazonEC2Client().createTags(
    	request.withResources( instanceId ).withTags( new Tag( "Name", instanceName ) )
    )
}

AmazonEC2 getAmazonEC2Client() {
	return project.extensions.getByType( AmazonEC2PluginExtension.class ).client
}


//---------------------------------------------- AWS/RDS Instances ----------------------------------------------//

if (hasProperty('dbInstanceEndpoint') == false) { ext.dbInstanceEndpoint = "" }


task createDBInstance(type: AmazonRDSCreateDBInstanceTask) {
	doFirst {
		dbInstanceIdentifier = properties.getProperty( "dbInstanceIdentifier" + project.instanceTargetDb )

		engine = properties.getProperty( "dbEngine" + project.instanceTargetDb )
		dbInstanceClass = properties.getProperty( "dbInstanceClass" + project.instanceTargetDb )

		engineVersion = properties.getProperty( "dbEngineVersion" + project.instanceTargetDb )
		port = properties.getProperty( "dbPort" + project.instanceTargetDb ).toInteger()
		licenseModel = properties.getProperty( "dbLicenseModel" + project.instanceTargetDb )
		publiclyAccessible = properties.getProperty( "dbPubliclyAccessible" + project.instanceTargetDb ).toBoolean()
		allocatedStorage = properties.getProperty( "dbAllocatedStorage" + project.instanceTargetDb ).toInteger()

		if ( ! "MSSQL".equalsIgnoreCase( project.instanceTargetDb ) ) {
			dbName = properties.getProperty( "dbDbName" + project.instanceTargetDb )
		}

		masterUsername = properties.getProperty( "dbMasterUsername" + project.instanceTargetDb )
		masterUserPassword = properties.getProperty( "dbMasterUserPassword" + project.instanceTargetDb )

		backupRetentionPeriod = properties.getProperty( "dbBackupRetentionPeriod" + project.instanceTargetDb ).toInteger()
		multiAZ = properties.getProperty( "dbMultiAZ" + project.instanceTargetDb ).toBoolean()
		autoMinorVersionUpgrade = properties.getProperty( "dbAutoMinorVersionUpgrade" + project.instanceTargetDb ).toBoolean()

		vpcSecurityGroupIds = new java.util.ArrayList<String>()
		vpcSecurityGroupIds += properties.getProperty("awsSecurityGroupId")
	}

	doLast {
		println("Created Database = "+ dbInstance)
	}
}


task deleteDBInstance(type: AmazonRDSDeleteDBInstanceTask) {
	skipFinalSnapshot = true

	doFirst {
		dbInstanceIdentifier = properties.getProperty( "dbInstanceIdentifier" + project.instanceTargetDb )
	}
}

task waitDBInstanceStatusCreated(type: AmazonRDSWaitInstanceStatusTask) {
	loopWait = 2

	successStatuses = [ "available", "terminated" ]

	waitStatuses = [ "backing-up", "creating", "deleting", "modifying", "rebooting", "renaming", "resetting-master-credentials" ]

	doFirst {
		dbInstanceIdentifier = properties.getProperty( "dbInstanceIdentifier" + project.instanceTargetDb )
	}
}


task describeDBInstance {
	doLast {
		String endpoint = getDBInstanceEndpoint( properties.getProperty( "dbInstanceIdentifier" + project.instanceTargetDb ) )

		project.dbInstanceEndpoint = endpoint;

		println("Described DB Instance = "+ endpoint )
	}
}


task setupDBInstance(dependsOn: describeDBInstance) {
	doLast {
		String dbDriverClassName = properties.getProperty( "dbDriver" + project.instanceTargetDb )
		String dbInstanceEndpoint = project.dbInstanceEndpoint;
		String dbInstanceName = properties.getProperty( "dbDbName" + project.instanceTargetDb )
		String dbInstancePort = properties.getProperty( "dbPort" + project.instanceTargetDb )
		String dbInstanceUsername = properties.getProperty( "dbMasterUsername" + project.instanceTargetDb )
		String dbInstancePassword = properties.getProperty( "dbMasterUserPassword" + project.instanceTargetDb )
		String dbInstanceSlaveUsername = properties.getProperty( "dbSlaveUsername" + project.instanceTargetDb )
		String dbInstanceSlavePassword = properties.getProperty( "dbSlaveUserPassword" + project.instanceTargetDb )

		Class.forName( dbDriverClassName, true, GroovyObject.class.classLoader )

		switch( project.instanceTargetDb ) {

			case "MySQL":
				String dbInstanceUrl = "jdbc:mysql://${dbInstanceEndpoint}:${dbInstancePort}/${dbInstanceName}?characterEncoding=UTF-8"

				groovy.sql.Sql sql = groovy.sql.Sql.newInstance(
					dbInstanceUrl, dbInstanceUsername, dbInstancePassword, dbDriverClassName
				)

				sql.execute( "ALTER DATABASE "+ dbInstanceName +" CHARACTER SET utf8 COLLATE utf8_general_ci;" )

				break;

			case "MSSQL":
				String dbInstanceUrl = "jdbc:jtds:sqlserver://${dbInstanceEndpoint}:${dbInstancePort};databaseName=master";

				groovy.sql.Sql sql = groovy.sql.Sql.newInstance(
					dbInstanceUrl, dbInstanceUsername, dbInstancePassword, dbDriverClassName
				)

				sql.execute( "CREATE DATABASE "+ dbInstanceName )
				sql.execute( "ALTER DATABASE "+ dbInstanceName +" SET READ_COMMITTED_SNAPSHOT ON;" )
				sql.execute( "ALTER DATABASE "+ dbInstanceName +" SET ALLOW_SNAPSHOT_ISOLATION ON;" )				

				break;

			case "Oracle":
				String dbInstanceUrl = "jdbc:oracle:thin:@${dbInstanceEndpoint}:${dbInstancePort}:${dbInstanceName}";

				groovy.sql.Sql sql = groovy.sql.Sql.newInstance(
					dbInstanceUrl, dbInstanceUsername, dbInstancePassword, dbDriverClassName
				)

				sql.execute( "CREATE USER \""+ dbInstanceSlaveUsername +"\" PROFILE \"DEFAULT\" IDENTIFIED BY \""+ dbInstanceSlavePassword +"\"" )
				sql.execute( "GRANT DBA TO "+ dbInstanceSlaveUsername )
				sql.execute( "GRANT CONNECT, RESOURCE TO "+ dbInstanceSlaveUsername )


				groovy.sql.Sql sql2 = groovy.sql.Sql.newInstance(
					dbInstanceUrl, dbInstanceSlaveUsername, dbInstanceSlavePassword, dbDriverClassName
				)

				sql2.execute( "CREATE OR REPLACE TRIGGER WORKAROUNDORA9965278 AFTER LOGON ON DATABASE BEGIN EXECUTE IMMEDIATE \'ALTER SESSION SET \"_replace_virtual_columns\"=false\'; END" )

				break;
		}
	}
}


String getDBInstanceEndpoint(String dbInstanceIdentifier) {
	DescribeDBInstancesResult describeDBInstancesResult = getAmazonRDSClient().describeDBInstances(
		new DescribeDBInstancesRequest().withDBInstanceIdentifier(dbInstanceIdentifier)
	);

	String endpoint = describeDBInstancesResult.getDBInstances().get(0).getEndpoint();

	return endpoint.replaceAll("^\\{.*Address:\\s*([^,]+).*\\}\$", "\$1");
}

AmazonRDS getAmazonRDSClient() {
	return project.extensions.getByType( AmazonRDSPluginExtension.class ).client
}
